<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>509</string>
	<key>AMApplicationVersion</key>
	<string>2.10</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0.3</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>COMMAND_STRING</key>
					<dict/>
					<key>CheckedForUserDefaultShell</key>
					<dict/>
					<key>inputMethod</key>
					<dict/>
					<key>shell</key>
					<dict/>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run Shell Script.action</string>
				<key>ActionName</key>
				<string>Run Shell Script</string>
				<key>ActionParameters</key>
				<dict>
					<key>COMMAND_STRING</key>
					<string>#!/usr/bin/env ruby
# encoding: utf-8

SILENT = ENV['SL_SILENT'] =~ /false/i ? false : true || true
VERSION = '2.2.20'

# SearchLink by Brett Terpstra 2015 &lt;http://brettterpstra.com/projects/searchlink/&gt;
# MIT License, please maintain attribution
require 'net/https'
require 'uri'
require 'rexml/document'
require 'shellwords'
require 'yaml'
require 'cgi'
require 'fileutils'
require 'zlib'
require 'time'
require 'json'
require 'erb'

if RUBY_VERSION.to_f &gt; 1.9
  Encoding.default_external = Encoding::UTF_8
  Encoding.default_internal = Encoding::UTF_8
end

PINBOARD_CACHE = File.expand_path("~/.searchlink_cache")

class Array
  def longest_element
    group_by(&amp;:size).max.last[0]
  end
end

class String
  def clean
    gsub(/\n+/,' ').gsub(/"/,"&amp;quot").gsub(/\|/,"-").gsub(/([&amp;\?]utm_[scm].+=[^&amp;\s!,\.\)\]]++?)+(&amp;.*)/, '\2').sub(/\?&amp;/,'').strip
  end

  def to_am # convert itunes to apple music link
    input = self.dup
    input.sub!(/\/itunes\.apple\.com/,'geo.itunes.apple.com')
    append = input =~ /\?[^\/]+=/ ? '&amp;app=music' : '?app=music'
    input + append
  end

  def path_elements
    path = URI.parse(self).path
    path.sub!(/\/?$/,'/')
    path.sub!(/\/[^\/]+[\.\-][^\/]+\/$/,'')
    path.gsub!(/(^\/|\/$)/,'')
    path.split(/\//).delete_if {|section| section =~ /^\d+$/ || section.length &lt; 5 }
  end

  def close_punctuation!
    self.replace close_punctuation
  end

  def close_punctuation
    return self unless self =~ /[“‘\[\(&lt;]/

    words = self.split(/\s+/)

    punct_chars = {
      '“' =&gt; '”',
      '‘' =&gt; '’',
      '[' =&gt; ']',
      '(' =&gt; ')',
      '&lt;' =&gt; '&gt;'
    }
    left_punct = []

    words.each {|w|

      punct_chars.each {|k,v|

        if w =~ /#{Regexp.escape(k)}/
            left_punct.push(k)
        end

        if w =~ /#{Regexp.escape(v)}/
          left_punct.delete_at(left_punct.rindex(k))
        end
      }
    }
    tail = ""
    left_punct.reverse.each {|c|
      tail += punct_chars[c]
    }

    self.gsub(/[^a-z\)\]’”\.…]+$/i,"...").strip + tail

  end

  def remove_seo!(url)
    self.replace remove_seo(url)
  end

  def remove_seo(url)
    title = self.dup
    url = URI.parse(url)
    host = url.hostname
    path = url.path
    root_page = path =~ /^\/?$/ ? true : false

    title.gsub!(/\s*(&amp;ndash;|&amp;mdash;)\s*/,' - ')
    title.gsub!(/&amp;[lr]dquo;/,'"')
    title.gsub!(/&amp;[lr]dquo;/,"'")

    seo_title_separators = [ '|', '«', '-', '–', '·', ':' ]

    begin
      re_parts = []

      host_parts = host.sub(/(?:www\.)?(.*?)\.[^\.]+$/,'\1').split(/\./).delete_if {|p| p.length &lt; 3 }
      h_re = host_parts.length &gt; 0 ? host_parts.map{|seg| seg.downcase.split(//).join('.?') }.join('|') : ''
      re_parts.push(h_re) if h_re.length &gt; 0

      # p_re = path.path_elements.map{|seg| seg.downcase.split(//).join('.?') }.join('|')
      # re_parts.push(p_re) if p_re.length &gt; 0

      site_re = "(#{re_parts.join('|')})"

      dead_switch = 0

      while title.downcase.gsub(/[^a-z]/i,'') =~ /#{site_re}/i

        break if dead_switch &gt; 5

        seo_title_separators.each_with_index do |sep, i|
          parts = title.split(/ ?#{Regexp.escape(sep)} +/)

          next if parts.length == 1
          remaining_separators = seo_title_separators[i..-1].map {|s| Regexp.escape(s)}.join('')
          seps = Regexp.new("^[^#{remaining_separators}]+$")

          longest = parts.longest_element.strip

          parts.delete_if {|pt|
            compressed = pt.strip.downcase.gsub(/[^a-z]/i,'')
            compressed =~ /#{site_re}/ &amp;&amp; pt =~ seps ? !root_page : false
          } if parts.length &gt; 1

          if parts.length == 0
            title = longest
          elsif parts.length &lt; 2
            title = parts.join(sep)
          elsif parts.length &gt; 2
            title = parts.longest_element.strip
          else
            title = parts.join(sep)
          end

        end
        dead_switch += 1
      end
    rescue Exception =&gt; e
      return self unless $cfg['debug']
      $stderr.puts "Error processing title"
      p e
      raise e
      # return self
    end

    seps = Regexp.new("[#{seo_title_separators.map {|s| Regexp.escape(s) }.join('')}]")
    if title =~ seps
      seo_parts = title.split(seps)
      if seo_parts.length &gt; 1
        title = seo_parts.longest_element.strip
      end
    end

    title &amp;&amp; title.length &gt; 5 ? title.gsub(/\s+/,' ') : self
  end

  def truncate!(max)
    self.replace truncate(max)
  end

  def truncate(max)
    return self if self.length &lt; max

    max -= 3
    counter = 0
    trunc_title = ""

    words = self.split(/\s+/)
    while trunc_title.length &lt; max &amp;&amp; counter &lt; words.length
      trunc_title += " " + words[counter]
      break if trunc_title.length + 1 &gt; max
      counter += 1
    end



    trunc_title = words[0] if trunc_title.nil? || trunc_title.length == 0

    trunc_title
  end
end

class SearchLink
  attr_reader :originput, :output, :clipboard
  attr_accessor :cfg
  # Values found in ~/.searchlink will override defaults in
  # this script

  def initialize(opt={})

    @printout = opt[:echo] || false
    unless File.exists? File.expand_path("~/.searchlink")
      default_config =&lt;&lt;ENDCONFIG
# set to true to have an HTML comment included detailing any errors
debug: true
# set to true to have an HTML comment included reporting results
report: true

# use Notification Center to display progress
notifications: false

# when running on a file, back up original to *.bak
backup: true

# change this to set a specific country for search (default US)
country_code: US

# set to true to force inline Markdown links
inline: false

# set to true to include a random string in reference titles.
# Avoids conflicts if you're only running on part of a document
# or using SearchLink multiple times within a document
prefix_random: true

# set to true to add titles to links based on the page title
# of the search result
include_titles: false

# confirm existence (200) of generated links. Can be disabled
# per search with `--v`, or enabled with `++v`.
validate_links: false

# If the link text is left empty, always insert the page title
# E.g. [](!g Search Text)
empty_uses_page_title: false

# Formatting for social links, use %service%, %user%, and %url%
# E.g. "%user% on %service%" =&gt; "ttscoff on Twitter"
#      "%service%/%user%" =&gt; "Twitter/ttscoff"
#      "%url%" =&gt; "twitter.com/ttscoff"
social_template: "%service%/%user%"

# append affiliate link info to iTunes urls, empty quotes for none
# example:
# itunes_affiliate: "&amp;at=10l4tL&amp;ct=searchlink"
itunes_affiliate: "&amp;at=10l4tL&amp;ct=searchlink"

# to create Amazon affiliate links, set amazon_partner to your amazon
# affiliate tag
#    amazon_partner: "bretttercom-20"
amazon_partner: "bretttercom-20"

# To create custom abbreviations for Google Site Searches,
# add to (or replace) the hash below.
# "abbreviation" =&gt; "site.url",
# This allows you, for example to use [search term](!bt)
# as a shortcut to search brettterpstra.com (using a site-specific
# Google search). Keys in this list can override existing
# search trigger abbreviations.
#
# If a custom search starts with "http" or "/", it becomes
# a simple replacement. Any instance of "$term" is replaced
# with a URL-escaped version of your search terms.
# Use $term1, $term2, etc. to replace in sequence from
# multiple search terms. No instances of "$term" functions
# as a simple shortcut. "$term" followed by a "d" lowercases
# the replacement. Use "$term1d," "$term2d" to downcase
# sequential replacements (affected individually).
# Long flags (e.g. --no-validate_links) can be used after
# any url in the custom searches.
custom_site_searches:
  bt: brettterpstra.com
  btt: http://brettterpstra.com/$term1d/$term2d
  bts: /search/$term --no-validate_links
  md: www.macdrifter.com
  ms: macstories.net
  dd: www.leancrew.com
  spark: macsparky.com
  man: http://man.cx/$term
  dev: developer.apple.com
  nq: http://nerdquery.com/?media_only=0&amp;query=$term&amp;search=1&amp;category=-1&amp;catid=&amp;type=and&amp;results=50&amp;db=0&amp;prefix=0
  gs: http://scholar.google.com/scholar?btnI&amp;hl=en&amp;q=$term&amp;btnG=&amp;as_sdt=80006
# Remove or comment (with #) history searches you don't want
# performed by `!h`. You can force-enable them per search, e.g.
# `!hsh` (Safari History only), `!hcb` (Chrome Bookmarks only),
# etc. Multiple types can be strung together: !hshcb (Safari
# History and Chrome bookmarks).
history_types:
- chrome_history
- chrome_bookmarks
- safari_bookmarks
- safari_history
# Pinboard search
# You can find your api key here: https://pinboard.in/settings/password
pinboard_api_key: ''

ENDCONFIG
      File.open(File.expand_path("~/.searchlink"), 'w') do |f|
        f.puts default_config
      end
    end

    @cfg = YAML.load_file(File.expand_path("~/.searchlink"))

    # set to true to have an HTML comment inserted showing any errors
    @cfg['debug'] ||= false

    # set to true to get a verbose report at the end of multi-line processing
    @cfg['report'] ||= false

    @cfg['backup'] = true unless @cfg.has_key? 'backup'

    # set to true to force inline links
    @cfg['inline'] ||= false

    # set to true to add titles to links based on site title
    @cfg['include_titles'] ||= false

    # set to true to use page title as link text when empty
    @cfg['empty_uses_page_title'] ||= false

    # change this to set a specific country for search (default US)
    @cfg['country_code'] ||= "US"

    # set to true to include a random string in ref titles
    # allows running SearchLink multiple times w/out conflicts
    @cfg['prefix_random'] = false unless @cfg['prefix_random']

    @cfg['social_template'] ||= '%service%/%user%'

    # append affiliate link info to iTunes urls, empty quotes for none
    # example:
    # $itunes_affiliate = "&amp;at=10l4tL&amp;ct=searchlink"
    @cfg['itunes_affiliate'] ||= '&amp;at=10l4tL&amp;ct=searchlink'

    # to create Amazon affiliate links, set amazon_partner to your amazon
    # affiliate tag
    #    amazon_partner: "bretttercom-20"
    @cfg['amazon_partner'] ||= ''

    # To create custom abbreviations for Google Site Searches,
    # add to (or replace) the hash below.
    # "abbreviation" =&gt; "site.url",
    # This allows you, for example to use [search term](!bt)
    # as a shortcut to search brettterpstra.com. Keys in this
    # hash can override existing search triggers.
    @cfg['custom_site_searches'] ||= {
      "bt" =&gt; "brettterpstra.com",
      "md" =&gt; "www.macdrifter.com"
    }

    # confirm existence of links generated from custom search replacements
    @cfg['validate_links'] ||= false

    # use notification center to show progress
    @cfg['notifications'] ||= false
    @cfg['pinboard_api_key'] ||= false

    @line_num = nil;
    @match_column = nil;
    @match_length = nil;
  end

  def available_searches
    searches = [
      ["a", "Amazon"],
      ["g", "Google"],
      ["wiki", "Wikipedia"],
      ["s", "Software search (Google)"],
      ["@t", "Twitter user link"],
      ["@f", "Facebook user link"],
      ["@l", "LinkedIn user link"],
      ["@i", "Instagram user link"],
      ["am", "Apple Music"],
      ["amart", "Apple Music Artist"],
      ["amalb", "Apple Music Album"],
      ["amsong", "Apple Music Song"],
      ["ampod", "Apple Music Podcast"],
      ["ipod", "iTunes podcast"],
      ["isong", "iTunes song"],
      ["iart", "iTunes artist"],
      ["ialb", "iTunes album"],
      ["lsong", "Last.fm song"],
      ["lart", "Last.fm artist"],
      ["mas", "Mac App Store"],
      ["masd", "Mac App Store developer link"],
      ["itu", "iTunes App Store"],
      ["itud", "iTunes App Store developer link"],
      ["imov","iTunes Movies"],
      ["def", "Dictionary definition"],
      ["sp", "Spelling"],
      ["pb", "Pinboard"]
      # ["h", "Web history"],
      # ["hs[hb]", "Safari [history, bookmarks]"],
      # ["hc[hb]", "Chrome [history, bookmarks]"]
    ]
    out = ""
    searches.each {|s|
      out += "!#{s[0]}#{spacer(s[0])}#{s[1]}\n"
    }
    out
  end

  def spacer(str)
    len = str.length
    str.scan(/[mwv]/).each do |tt|
      len += 1
    end
    str.scan(/[t]/).each do |tt|
      len -= 1
    end
    spacer = case len
    when 0..3
      "\t\t"
    when 4..12
      " \t"
    end
    spacer
  end

  def get_help_text
    help_text =&lt;&lt;EOHELP
-- [Available searches] -------------------
#{available_searches}
EOHELP

    if @cfg['custom_site_searches']
      help_text += "\n-- [Custom Searches] ----------------------\n"
      @cfg['custom_site_searches'].each {|label, site|
        help_text += "!#{label}#{spacer(label)} #{site}\n"
      }
    end
    help_text
  end

  def help_dialog
    help_text = "[SearchLink v#{VERSION}]\n\n"
    help_text += get_help_text
    help_text += "\nClick \\\"More Help\\\" for additional information"
    res = %x{osascript &lt;&lt;'APPLESCRIPT'
set _res to display dialog "#{help_text.gsub(/\n/,'\\\n')}" buttons {"OK", "More help"} default button "OK" with title "SearchLink Help"

return button returned of _res
APPLESCRIPT
    }.strip
    if res == "More help"
      %x{open http://brettterpstra.com/projects/searchlink}
    end
  end

  def help_cli
    $stdout.puts get_help_text
  end

  def parse(input)
    @output = ''
    return false unless input &amp;&amp; input.length &gt; 0
    parse_arguments(input, {:only_meta =&gt; true})
    @originput = input.dup

    if input.strip =~ /^help$/i
      if SILENT
        help_dialog # %x{open http://brettterpstra.com/projects/searchlink/}
      else
        $stdout.puts "SearchLink v#{VERSION}"
        $stdout.puts "See http://brettterpstra.com/projects/searchlink/ for help"
      end
      print input
      Process.exit
    end

    @cfg['inline'] = true if input.scan(/\]\(/).length == 1 &amp;&amp; input.split(/\n/).length == 1
    @errors = {}
    @report = []

    links = {}
    @footer = []
    counter_links = 0
    counter_errors = 0

    input.sub!(/\n?&lt;!-- Report:.*?--&gt;\n?/m, '')
    input.sub!(/\n?&lt;!-- Errors:.*?--&gt;\n?/m, '')

    input.scan(/\[(.*?)\]:\s+(.*?)\n/).each {|match|
      links[match[1].strip] = match[0]
    }

    if @cfg['prefix_random']
      if input =~ /\[(\d{4}-)\d+\]: \S+/
        prefix = $1
      else
        prefix = ("%04d" % rand(9999)).to_s + "-"
      end
    else
      prefix = ""
    end

    highest_marker = 0
    input.scan(/^\s{,3}\[(?:#{prefix})?(\d+)\]: /).each do |match|
      highest_marker = $1.to_i if $1.to_i &gt; highest_marker
    end

    footnote_counter = 0
    input.scan(/^\s{,3}\[\^(?:#{prefix})?fn(\d+)\]: /).each do |match|
      footnote_counter = $1.to_i if $1.to_i &gt; footnote_counter
    end

    if input =~ /\[(.*?)\]\((.*?)\)/
      lines = input.split(/\n/)
      out = []

      total_links = input.scan(/\[(.*?)\]\((.*?)\)/).length
      in_code_block = false
      line_difference = 0
      lines.each_with_index {|line, num|
        @line_num = num - line_difference
        cursor_difference = 0
        # ignore links in code blocks
        if line =~ /^( {4,}|\t+)[^\*\+\-]/
          out.push(line)
          next
        end
        if line =~ /^[~`]{3,}/
          if in_code_block
            in_code_block = false
            out.push(line)
            next
          else
            in_code_block = true
          end
        end
        if in_code_block
          out.push(line)
          next
        end

        # line.gsub!(/\(\$ (.*?)\)/) do |match|
        #   this_match = Regexp.last_match
        #   match_column = this_match.begin(0)
        #   match_string = this_match.to_s
        #   match_before = this_match.pre_match
        #   match_after = this_match.post_match
        #   # todo: inline searches in larger context
        # end

        delete_line = false

        line.gsub!(/\[(.*?)\]\((.*?)\)/) do |match|

          this_match = Regexp.last_match
          @match_column = this_match.begin(0) - cursor_difference
          match_string = this_match.to_s
          @match_length = match_string.length
          match_before = this_match.pre_match

          invalid_search = false
          ref_title = false

          if match_before.scan(/(^|[^\\])`/).length % 2 == 1
            add_report("Match '#{match_string}' within an inline code block")
            invalid_search = true
          end

          counter_links += 1
          $stderr.print("\033[0K\rProcessed: #{counter_links} of #{total_links}, #{counter_errors} errors. ") unless SILENT

          link_text = this_match[1] || ''
          link_info = parse_arguments(this_match[2].strip).strip || ''

          if link_text.strip == '' &amp;&amp; link_info =~ /".*?"/
            link_info.gsub!(/\"(.*?)\"/) {|q|
              link_text = $1 if link_text == ''
              $1
            }
          end

          if link_info.strip =~ /:$/ &amp;&amp; line.strip == match
            ref_title = true
            link_info.sub!(/\s*:\s*$/,'')
          end

          unless link_text.length &gt; 0 || link_info.sub(/^[!\^]\S+/,'').strip.length &gt; 0
            add_error('No input', match)
            counter_errors += 1
            invalid_search = true
          end

          if link_info =~ /^!(\S+)/
            search_type = $1
            unless valid_search?(search_type) || search_type =~ /^(\S+\.)+\S+$/
              add_error('Invalid search', match)
              invalid_search = true
            end
          end


          if invalid_search
            match
          elsif link_info =~ /^\^(.+)/
            if $1.nil? || $1 == ''
              match
            else
              note = $1.strip
              footnote_counter += 1
              if link_text.length &gt; 0 &amp;&amp; link_text.scan(/\s/).length == 0
                ref = link_text
              else
                ref = prefix + "fn" + ("%04d" % footnote_counter).to_s
              end
              add_footer "[^#{ref}]: #{note}"
              res = %Q{[^#{ref}]}
              cursor_difference = cursor_difference + (@match_length - res.length)
              @match_length = res.length
              add_report("#{match_string} =&gt; Footnote #{ref}")
              res
            end
          elsif (link_text == "" &amp;&amp; link_info == "") || is_url?(link_info)
            add_error('Invalid search', match) unless is_url?(link_info)
            match
          else

            if link_text.length &gt; 0 &amp;&amp; link_info == ""
              link_info = link_text
            end

            search_type = ''
            search_terms = ''
            link_only = false
            @clipboard = false
            @titleize = @cfg['empty_uses_page_title']


            if link_info =~ /^(?:[!\^](\S+))\s*(.*)$/

              if $1.nil?
                search_type = 'g'
              else
                search_type = $1
              end

              search_terms = $2.gsub(/(^["']|["']$)/, '')
              search_terms.strip!

              # if the link text is just '%' replace with title regardless of config settings
              if link_text == '%' &amp;&amp; search_terms &amp;&amp; search_terms.length &gt; 0
                @titleize = true
                link_text = ''
              end

              search_terms = link_text if search_terms == ''

              # if the input starts with a +, append it to the link text as the search terms
              search_terms = link_text + " " + search_terms.strip.sub(/^\+\s*/, '') if search_terms.strip =~ /^\+[^\+]/

              # if the end of input contain "^", copy to clipboard instead of STDOUT
              @clipboard = true if search_terms =~ /(!!)?\^(!!)?$/

              # if the end of input contains "!!", only print the url
              link_only = true if search_terms =~ /!!\^?$/

              search_terms.sub!(/(!!)?\^?(!!)?$/,"")

            elsif link_info =~ /^\!/
              search_word = link_info.match(/^\!(\S+)/)

              if search_word &amp;&amp; valid_search?(search_word[1])
                search_type = search_word[1] unless search_word.nil?
                search_terms = link_text
              elsif search_word &amp;&amp; search_word[1] =~ /^(\S+\.)+\S+$/
                search_type = 'g'
                search_terms = "site:#{search_word[1]} #{link_text}"
              else
                add_error('Invalid search', match)
                search_type = false
                search_terms = false
              end

            elsif link_text &amp;&amp; link_text.length &gt; 0 &amp;&amp; (link_info.nil? || link_info.length == 0)

              search_type = 'g'
              search_terms = link_text
            else
              add_error('Invalid search', match)
              search_type = false
              search_terms = false
            end



            @cfg['custom_site_searches'].each {|k,v|
              if search_type == k
                link_text = search_terms if link_text == '' unless @titleize
                v = parse_arguments(v, {:no_restore =&gt; true})
                if v =~ /^(\/|http)/i
                  search_type = 'r'
                  tokens = v.scan(/\$term\d+d?/).sort.uniq

                  if tokens.length &gt; 0
                    highest_token = 0
                    tokens.each {|token|
                      if token =~ /(\d+)d?$/
                        highest_token = $1.to_i if $1.to_i &gt; highest_token
                      end
                    }
                    terms_p = search_terms.split(/ +/)
                    if terms_p.length &gt; highest_token
                      remainder = terms_p[highest_token-1..-1].join(" ")
                      terms_p = terms_p[0..highest_token - 2]
                      terms_p.push(remainder)
                    end
                    tokens.each {|t|
                      if t =~ /(\d+)d?$/
                        int = $1.to_i - 1
                        replacement = terms_p[int]
                        if t =~ /d$/
                          replacement.downcase!
                          re_down = ""
                        else
                          re_down = "(?!d)"
                        end
                        v.gsub!(/#{Regexp.escape(t)+re_down}/, ERB::Util.url_encode(replacement))
                      end
                    }
                    search_terms = v


                  else
                    search_terms = v.gsub(/\$termd?/i) {|m|
                      search_terms.downcase! if m =~ /d$/i
                      ERB::Util.url_encode(search_terms)
                    }
                  end

                else
                  search_type = 'g'
                  search_terms = "site:#{v} #{search_terms}"
                end

                break
              end
            } if search_type &amp;&amp; search_terms &amp;&amp; search_terms.length &gt; 0

            if search_type &amp;&amp; search_terms
              url = false
              title = false
              force_title = false
              # $stderr.puts "Searching #{search_type} for #{search_terms}"
              url, title, link_text = do_search(search_type, search_terms, link_text)


              if url
                if @titleize &amp;&amp; title == ''
                  title = titleize(url)
                end
                link_text = title if link_text == '' &amp;&amp; title
                force_title = search_type =~ /def/ ? true : false

                if link_only || search_type =~ /sp(ell)?/ || url == 'embed'
                  url = title if url == 'embed'
                  cursor_difference = cursor_difference + (@match_length - url.length)
                  @match_length = url.length
                  add_report("#{match_string} =&gt; #{url}")
                  url
                elsif ref_title
                  unless links.has_key? url
                    links[url] = link_text
                    add_footer make_link('ref_title', link_text, url, title, force_title)
                  end
                  delete_line = true
                elsif @cfg['inline']
                  res = make_link('inline', link_text, url, title, force_title)
                  cursor_difference = cursor_difference + (@match_length - res.length)
                  @match_length = res.length
                  add_report("#{match_string} =&gt; #{url}")
                  res
                else
                  unless links.has_key? url
                    highest_marker += 1
                    links[url] = prefix + ("%04d" % highest_marker).to_s
                    add_footer make_link('ref_title', links[url], url, title, force_title)
                  end

                  type = @cfg['inline'] ? 'inline' : 'ref_link'
                  res = make_link(type, link_text, links[url], false, force_title)
                  cursor_difference = cursor_difference + (@match_length - res.length)
                  @match_length = res.length
                  add_report("#{match_string} =&gt; #{url}")
                  res
                end
              else
                add_error('No results', "#{search_terms} (#{match_string})")
                counter_errors += 1
                match
              end
            else
              add_error('Invalid search', match)
              counter_errors += 1
              match
            end
          end
        end
        line_difference += 1 if delete_line
        out.push(line) unless delete_line
        delete_line = false
      }
      $stderr.puts("\n") unless SILENT

      input = out.delete_if {|l|
        l.strip =~ /^&lt;!--DELETE--&gt;$/
      }.join("\n")

      if @cfg['inline']
        add_output input + "\n"
        add_output "\n" + print_footer unless @footer.empty?
      else
        if @footer.empty?
          add_output input
        else
          last_line = input.strip.split(/\n/)[-1]
          if last_line =~ /^\[.*?\]: http/
            add_output input.rstrip + "\n"
          elsif last_line =~ /^\[\^.*?\]: /
            add_output input.rstrip
          else
            add_output input + "\n\n"
          end
          add_output print_footer + "\n\n"
        end
      end
      @line_num = nil
      add_report("Processed: #{total_links} links, #{counter_errors} errors.")
      print_report
      print_errors
    else
      link_only = false
      @clipboard = false

      input = parse_arguments(input.strip!).strip

      # if the end of input contain "^", copy to clipboard instead of STDOUT
      @clipboard = true if input =~ /\^[!~:]*$/

      # if the end of input contains "!!", only print the url
      link_only = true if input =~ /!![\^~:]*$/

      reference_link = input =~ /:([!\^\s~]*)$/

      # if end of input contains ~, pull url from clipboard
      if input =~ /~[:\^!\s]*$/
        input.sub!(/[:!\^\s~]*$/,'')
        clipboard = %x{__CF_USER_TEXT_ENCODING=$UID:0x8000100:0x8000100 pbpaste}.strip
        if is_url?(clipboard)
          type = reference_link ? 'ref_title' : 'inline'
          print make_link(type, input.strip, clipboard, false, false)
        else
          print @originput
        end
        Process.exit
      end

      input.sub!(/[:!\^\s~]*$/,'')

      ## Maybe if input is just a URL, convert it to a link
      ## using hostname as text without doing search
      # if only_url?(input.strip)
      #   url, title = url_to_link(input.strip)
      #   type = reference_link ? 'ref_title' : 'inline'
      #   print make_link(type, title, url, false, false)
      #   Process.exit
      # end

      # check for additional search terms in parenthesis
      additional_terms = ''
      if input =~ /\((.*?)\)/
        additional_terms = " " + $1.strip
        input.sub!(/\(.*?\)/,'')
      end

      link_text = false

      if input =~ /"(.*?)"/
        link_text = $1
        input.gsub!(/"(.*?)"/, '\1')
      end

      # remove quotes from terms, just in case
      # input.sub!(/^(!\S+)?\s*(["'])(.*?)\2([\!\^]+)?$/, "\\1 \\3\\4")

      if input =~ /^!(\S+)\s+(.*)$/
        type = $1
        link_info = $2.strip
        link_text = link_info unless link_text
        terms = link_info  + additional_terms
        terms.strip!

        if valid_search?(type) || type =~ /^(\S+\.)+\S+$/
          @cfg['custom_site_searches'].each {|k,v|
            if type == k
              link_text = terms if link_text == ''
              v = parse_arguments(v, {:no_restore =&gt; true})
              if v =~ /^(\/|http)/i
                type = 'r'
                tokens = v.scan(/\$term\d+d?/).sort.uniq

                if tokens.length &gt; 0
                  highest_token = 0
                  tokens.each {|token|
                    if token =~ /(\d+)d?$/
                      highest_token = $1.to_i if $1.to_i &gt; highest_token
                    end
                  }
                  terms_p = terms.split(/ +/)
                  if terms_p.length &gt; highest_token
                    remainder = terms_p[highest_token-1..-1].join(" ")
                    terms_p = terms_p[0..highest_token - 2]
                    terms_p.push(remainder)
                  end
                  tokens.each {|t|
                    if t =~ /(\d+)d?$/
                      int = $1.to_i - 1
                      replacement = terms_p[int]
                      if t =~ /d$/
                        replacement.downcase!
                        re_down = ""
                      else
                        re_down = "(?!d)"
                      end
                      v.gsub!(/#{Regexp.escape(t)+re_down}/, ERB::Util.url_encode(replacement))
                    end
                  }
                  terms = v


                else
                  terms = v.gsub(/\$termd?/i) {|m|
                    terms.downcase! if m =~ /d$/i
                    ERB::Util.url_encode(terms)
                  }
                end

              else
                type = 'g'
                terms = "site:#{v} #{terms}"
              end

              break
            end
          } if type &amp;&amp; terms &amp;&amp; terms.length &gt; 0

          if type =~ /^(\S+\.)+\S+$/
            terms = "site:#{type} #{terms}"
            type = 'g'
          end

          url, title, link_text = do_search(type, terms, link_text)
        else
          add_error('Invalid search', input)
          counter_errors += 1
        end
      elsif input =~ /^([tfil])?@(\S+)\s*$/
        type = $1 || 't'
        link_text = input.sub(/^[tfil]/,'')
        url, title = social_handle(type, link_text)
        link_text = title
      else
        link_text = input unless link_text
        url, title = ddg(input)
      end

      if url
        if type =~ /sp(ell)?/
          add_output(url)
        elsif link_only
          add_output(url)
        elsif url == 'embed'
          add_output(title)
        else
          type = reference_link ? 'ref_title' : 'inline'
          add_output make_link(type, link_text, url, title, false)
          print_errors
        end
      else
        add_error('No results', title)
        add_output @originput.chomp
        print_errors
      end

      if @clipboard
        if @output == @originput
          $stderr.puts "No results found"
        else
          %x{echo #{Shellwords.escape(@output)}|tr -d "\n"|pbcopy}
          $stderr.puts "Results in clipboard"
        end
      end
    end
  end

  private

  def parse_arguments(string, opt={})
    input = string.dup
    skip_flags = opt[:only_meta] || false
    no_restore = opt[:no_restore] || false
    restore_prev_config unless no_restore

    input.gsub!(/(\+\+|--)([dirtv]+)\b/) do |match|
      bool = $1 == "++" ? "" : "no-"
      output = " "
      $2.split('').each {|arg|
        output += case arg
        when 'd'
          "--#{bool}debug "
        when 'i'
          "--#{bool}inline "
        when 'r'
          "--#{bool}prefix_random "
        when 't'
          "--#{bool}include_titles "
        when 'v'
          "--#{bool}validate_links "
        else
          ""
        end
      }
      output
    end unless skip_flags

    options = %w{ debug country_code inline prefix_random include_titles validate_links }
    options.each {|o|
      if input =~ /^#{o}:\s+(.*?)$/
        val = $1.strip
        val = true if val =~ /true/i
        val = false if val =~ /false/i
        @cfg[o] = val
        $stderr.print "\r\033[0KGlobal config: #{o} = #{@cfg[o]}\n" unless SILENT
      end

      unless skip_flags
        while input =~ /^#{o}:\s+(.*?)$/ || input =~ /--(no-)?#{o}/ do

          if input =~ /--(no-)?#{o}/ &amp;&amp; !skip_flags
            unless @prev_config.has_key? o
              @prev_config[o] = @cfg[o]
              bool = $1.nil? || $1 == '' ? true : false
              @cfg[o] = bool
              $stderr.print "\r\033[0KLine config: #{o} = #{@cfg[o]}\n" unless SILENT
            end
            input.sub!(/\s?--(no-)?#{o}/, '')
          end
        end
      end
    }
    @clipboard ? string : input
  end

  def restore_prev_config
    @prev_config.each {|k,v|
      @cfg[k] = v
      $stderr.print "\r\033[0KReset config: #{k} = #{@cfg[k]}\n" unless SILENT
    } if @prev_config
    @prev_config = {}
  end

  def make_link(type, text, url, title=false, force_title=false)

    if (@titleize &amp;&amp; text == '')
      text = title ? title : titleize(url)
    end

    title = title &amp;&amp; (@cfg['include_titles'] || force_title) ? %Q{ "#{title.clean}"} : ""

    case type
    when 'ref_title'
      %Q{\n[#{text.strip}]: #{url}#{title}}
    when 'ref_link'
      %Q{[#{text.strip}][#{url}]}
    when 'inline'
      %Q{[#{text.strip}](#{url}#{title})}
    end
  end

  def add_output(str)
    if @printout &amp;&amp; !@clipboard
      print str
    end
    @output += str
  end

  def add_footer(str)
    @footer ||= []
    @footer.push(str.strip)
  end

  def print_footer
    unless @footer.empty?

      footnotes = []
      @footer.delete_if {|note|
        note.strip!
        if note =~ /^\[\^.+?\]/
          footnotes.push(note)
          true
        elsif note =~ /^\s*$/
          true
        else
          false
        end
      }

      output = @footer.sort.join("\n").strip
      output += "\n\n" if output.length &gt; 0 &amp;&amp; !footnotes.empty?
      output += footnotes.join("\n\n") unless footnotes.empty?
      return output.gsub(/\n{3,}/,"\n\n")
    end
    return ""
  end

  def add_report(str)
    if @cfg['report']
      unless @line_num.nil?
        position = @line_num.to_s + ':'
        position += @match_column.nil? ? "0:" : "#{@match_column}:"
        position += @match_length.nil? ? "0" : @match_length.to_s
      end
      @report.push("(#{position}): #{str}")
      $stderr.puts "(#{position}): #{str}" unless SILENT
    end
  end

  def add_error(type, str)
    if @cfg['debug']
      unless @line_num.nil?
        position = @line_num.to_s + ':'
        position += @match_column.nil? ? "0:" : "#{@match_column}:"
        position += @match_length.nil? ? "0" : @match_length.to_s
      end
      @errors[type] ||= []
      @errors[type].push("(#{position}): #{str}")
    end
  end

  def print_report
    return if (@cfg['inline'] &amp;&amp; @originput.split(/\n/).length == 1) || @clipboard
    unless @report.empty?
      out = "\n&lt;!-- Report:\n#{@report.join("\n")}\n--&gt;\n"
      add_output out
    end
  end

  def print_errors(type = 'Errors')
    return if @errors.empty?
    out = ''
    if @originput.split(/\n/).length &gt; 1
      inline = false
    else
      inline = @cfg['inline'] || @originput.split(/\n/).length == 1
    end

    @errors.each {|k,v|
      unless v.empty?
        v.each_with_index {|err, i|
          out += "(#{k}) #{err}"
          out += inline ? i == v.length - 1 ? " | " : ", " : "\n"
        }
      end
    }
    unless out == ''
      sep = inline ? " " : "\n"
      out.sub!(/\| /, '')
      out = "#{sep}&lt;!-- #{type}:#{sep}#{out}--&gt;#{sep}"
    end
    if @clipboard
      $stderr.puts out
    else
      add_output out
    end
  end

  def print_or_copy(text)
    # Process.exit unless text
    if @clipboard
      %x{echo #{Shellwords.escape(text)}|tr -d "\n"|pbcopy}
      print @originput
    else
      print text
    end
  end

  def notify(str, sub)
    return unless @cfg['notifications']
    %x{osascript -e 'display notification "SearchLink" with title "#{str}" subtitle "#{sub}"'}
  end

  def valid_link?(uri_str, limit = 5)
    begin
      notify("Validating", uri_str)
      return false if limit == 0
      url = URI(uri_str)
      return true unless url.scheme
      if url.path == ""
        url.path = "/"
      end
      # response = Net::HTTP.get_response(URI(uri_str))
      response = false

      Net::HTTP.start(url.host, url.port, :use_ssl =&gt; url.scheme == 'https') {|http| response = http.request_head(url.path) }

      case response
      when Net::HTTPMethodNotAllowed, Net::HTTPServiceUnavailable then
        unless /amazon\.com/ =~ url.host
          add_error('link validation', "Validation blocked: #{uri_str} (#{e})")
        end
        notify("Error validating", uri_str)
        true
      when Net::HTTPSuccess then
        true
      when Net::HTTPRedirection then
        location = response['location']
        valid_link?(location, limit - 1)
      else
        notify("Error validating", uri_str)
        false
      end
    rescue =&gt; e
      notify("Error validating", uri_str)
      add_error('link validation', "Possibly invalid =&gt; #{uri_str} (#{e})")
      return true
    end
  end

  def is_url?(input)
    input =~ /^(#.*|https?:\/\/\S+|\/\S+|\S+\/|[^!]\S+\.\S+)(\s+".*?")?$/
  end

  def only_url?(input)
    input =~ /(?i)^((http|https):\/\/)?([\w\-_]+(\.[\w\-_]+)+)([\w\-\.,@?^=%&amp;amp;:\/~\+#]*[\w\-\@^=%&amp;amp;\/~\+#])?$/
  end

  def url_to_link(input)
    if (only_url?(input))
      input.sub!( /(?mi)^(?!https?:\/\/)(.*?)$/, "https://\\1" )
      url = URI.parse(input.downcase)
      if (url.hostname)

        return [url.to_s, input.sub(/^https?:\/\//,'')]
      end
    end
    false
  end

  def valid_search?(term)
    valid = false
    valid = true if term =~ /(^h(([sc])([hb])?)*|^a$|^imov|^g$|^b$|^wiki$|^def$|^masd?$|^itud?$|^s$|^(i|am)(art|alb|song|pod)e?$|^lart|^@(t|f|i|l)|^r$|^sp(ell)?|pb$)/
    valid = true if @cfg['custom_site_searches'].keys.include? term
    notify("Invalid search", term) unless valid
    valid
  end

  def search_chrome_history(term)
    # Google history
    if File.exists?(File.expand_path('~/Library/Application Support/Google/Chrome/Default/History'))
      notify("Searching Chrome History", term)
      tmpfile = File.expand_path('~/Library/Application Support/Google/Chrome/Default/History.tmp')
      FileUtils.cp(File.expand_path('~/Library/Application Support/Google/Chrome/Default/History'), tmpfile)

      terms = []
      terms.push("(url NOT LIKE '%search/?%' AND url NOT LIKE '%?q=%' AND url NOT LIKE '%?s=%')")
      terms.concat(term.split(/\s+/).map {|t| "(url LIKE '%#{t.strip.downcase}%' OR title LIKE '%#{t.strip.downcase}%')" })
      query = terms.join(" AND ")
      most_recent = %x{sqlite3 -separator ' ;;; ' '#{tmpfile}' "select title,url,datetime(last_visit_time / 1000000 + (strftime('%s', '1601-01-01')), 'unixepoch') from urls where #{query} AND NOT (url LIKE '%?s=%' OR url LIKE '%/search%') order by last_visit_time limit 1 COLLATE NOCASE;"}.strip
      FileUtils.rm_f(tmpfile)
      return false if most_recent.strip.length == 0
      title, url, date = most_recent.split(/\s*;;; /)
      date = Time.parse(date)
      [url, title, date]
    else
      false
    end
  end

  def search_chrome_bookmarks(term)
    out = false
    if File.exists?(File.expand_path('~/Library/Application Support/Google/Chrome/Default/Bookmarks'))
      notify("Searching Chrome Bookmarks", term)
      chrome_bookmarks = JSON.parse(IO.read(File.expand_path('~/Library/Application Support/Google/Chrome/Default/Bookmarks')))
      if chrome_bookmarks
        terms = term.split(/\s+/)
        roots = chrome_bookmarks['roots']
        urls = extract_chrome_bookmarks(roots)
        urls.sort_by! {|bookmark| bookmark["date_added"]}
        urls.select {|u|
          found = false
          terms.each {|t|
            if u["url"] =~ /#{t}/i || u["title"] =~ /#{t}/
              found = true
            end
          }
          found
        }
        unless urls.empty?
          lastest_bookmark = urls[-1]
          out = [lastest_bookmark['url'], lastest_bookmark['title'], lastest_bookmark['date']]
        end
      end
    end
    out
  end

  def search_history(term,types = [])
    if types.empty?
      if @cfg['history_types']
        types = @cfg['history_types']
      else
        return false
      end
    end


    results = []

    if types.length &gt; 0
      types.each {|type|

        url, title, date = case type
        when 'chrome_history'
          search_chrome_history(term)
        when 'chrome_bookmarks'
          search_chrome_bookmarks(term)
        when 'safari_bookmarks'
          search_safari_urls(term, 'bookmark')
        when 'safari_history'
          search_safari_urls(term, 'history')
        when 'safari_all'
          search_safari_urls(term)
        else
          false
        end
        if url
          results &lt;&lt; {'url' =&gt; url, 'title' =&gt; title, 'date' =&gt; date}
        end
      }

      unless results.empty?
        out = results.sort_by! {|r| r['date'] }[-1]
        [out['url'], out['title']]
      else
        false
      end
    else
      false
    end
  end

  # FIXME: These spotlight searches no longer work on 10.13
  # Search Safari Bookmarks and/or history using spotlight
  #
  # @param (String) term
  # @param (String) type ['history'|'bookmark'|(Bool) false]
  #
  # @return (Array) [url, title, access_date] on success
  # @return (Bool) false on error
  def search_safari_urls(term,type = false)
    notify("Searching Safari History", term)
    onlyin = "~/Library/Caches/Metadata/Safari"
    onlyin += type ? "/"+type.capitalize : "/"
    type = type ? ".#{type}" : "*"
    # created:&gt;10/13/13 kind:safari filename:.webbookmark
    # Safari history/bookmarks
    terms = term.split(/\s+/).delete_if {|t| t.strip =~ /^\s*$/ }.map{|t|
      %Q{kMDItemTextContent = "*#{t}*"cdw}
    }.join(" &amp;&amp; ")

    date = type == ".history" ? "&amp;&amp; kMDItemContentCreationDate &gt; $time.today(-182) " : ""

    avoid_results = ["404", "not found", "chrome-extension"].map {|q|
      %Q{ kMDItemDisplayName != "*#{q}*"cdw }
    }.join(" &amp;&amp; ")
    query = %Q{((kMDItemContentType = "com.apple.safari#{type}") #{date}&amp;&amp; (#{avoid_results}) &amp;&amp; (#{terms}))}

    search = %x{mdfind -onlyin #{onlyin.gsub(/ /,'\ ')} '#{query}'}
    if search.length &gt; 0
      res = []
      search.split(/\n/).each {|file|
        url = %x{mdls -raw -name kMDItemURL "#{file}"}
        date = %x{mdls -raw -name kMDItemDateAdded "#{file}"}
        date = Time.parse(date)
        title = %x{mdls -raw -name kMDItemDisplayName "#{file}"}
        res &lt;&lt; {'url' =&gt; url, 'date' =&gt; date, 'title' =&gt; title}
      }
      res.delete_if {|k,el| el =~ /\(null\)/ }

      latest = res.sort_by! {|r| r["date"] }[-1]
      [latest['url'], latest['title'], latest['date']]
    else
      false
    end
  end

  def extract_chrome_bookmarks(json,urls = [])

    if json.class == Array
      json.each {|item|
        urls = extract_chrome_bookmarks(item, urls)
      }
    elsif json.class == Hash
      if json.has_key? "children"
        urls = extract_chrome_bookmarks(json["children"],urls)
      elsif json["type"] == "url"
        date = Time.at(json["date_added"].to_i / 1000000 + (Time.new(1601,01,01).strftime('%s').to_i))
        urls &lt;&lt; {'url' =&gt; json["url"], 'title' =&gt; json["name"], 'date' =&gt; date}
      else
        json.each {|k,v|
          urls = extract_chrome_bookmarks(v,urls)
        }

      end
    else
      return urls
    end
    urls
  end



  def wiki(terms)
    ## Hack to scrape wikipedia result
    body = %x{/usr/bin/curl -sSL 'https://en.wikipedia.org/wiki/Special:Search?search=#{ERB::Util.url_encode(terms)}&amp;go=Go'}
    if body
      if RUBY_VERSION.to_f &gt; 1.9
        body = body.force_encoding('utf-8')
      end

      begin
        title = body.match(/"wgTitle":"(.*?)"/)[1]
        url = body.match(/&lt;link rel="canonical" href="(.*?)"/)[1]
      rescue
        return false
      end
      return [url, title]
    end
    ## Removed because Ruby 2.0 does not like https connection to wikipedia without using gems?
    # uri = URI.parse("https://en.wikipedia.org/w/api.php?action=query&amp;format=json&amp;prop=info&amp;inprop=url&amp;titles=#{CGI.escape(terms)}")
    # req = Net::HTTP::Get.new(uri.path)
    # req['Referer'] = "http://brettterpstra.com"
    # req['User-Agent'] = "SearchLink (http://brettterpstra.com)"

    # res = Net::HTTP.start(uri.host, uri.port,
    #   :use_ssl =&gt; true,
    #   :verify_mode =&gt; OpenSSL::SSL::VERIFY_NONE) do |https|
    #     https.request(req)
    #   end



    # if RUBY_VERSION.to_f &gt; 1.9
    #   body = res.body.force_encoding('utf-8')
    # else
    #   body = res.body
    # end

    # result = JSON.parse(body)

    # if result
    #   result['query']['pages'].each do |page,info|
    #     unless info.key? "missing"
    #       return [info['fullurl'],info['title']]
    #     end
    #   end
    # end
    # return false
  end

  def zero_click(terms)
    url = URI.parse("http://api.duckduckgo.com/?q=#{ERB::Util.url_encode(terms)}&amp;format=json&amp;no_redirect=1&amp;no_html=1&amp;skip_disambig=1")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9

    result = JSON.parse(res)
    if result
      definition = result['Definition'] || false
      definition_link = result['DefinitionURL'] || false
      wiki_link = result['AbstractURL'] || false
      title = result['Heading'] || false
      return [title, definition, definition_link, wiki_link]
    else
      return false
    end
  end

  # Search apple music
  # terms =&gt; search terms (unescaped)
  # media =&gt; music, podcast
  # entity =&gt; optional: artist, song, album, podcast
  # returns {:type=&gt;,:id=&gt;,:url=&gt;,:title}
  def applemusic(terms, media='music', entity='')
    aff = @cfg['itunes_affiliate']
    output = {}

    url = URI.parse("http://itunes.apple.com/search?term=#{ERB::Util.url_encode(terms)}&amp;country=#{@cfg['country_code']}&amp;media=#{media}&amp;entity=#{entity}")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9
    res.gsub!(/(?mi)[\x00-\x08\x0B-\x0C\x0E-\x1F]/,'')
    json = JSON.parse(res)
    if json['resultCount'] &amp;&amp; json['resultCount'] &gt; 0
      result = json['results'][0]

      case result['wrapperType']
      when 'track'
        if result['kind'] == 'podcast'
          output[:type] = 'podcast'
          output[:id] = result['collectionId']
          output[:url] = result['collectionViewUrl'].to_am + aff
          output[:title] = result['collectionName']
        else
          output[:type] = 'song'
          output[:album] = result['collectionId']
          output[:id] = result['trackId']
          output[:url] = result['trackViewUrl'].to_am + aff
          output[:title] = result['trackName'] + " by " + result['artistName']
        end
      when 'collection'
        output[:type] = 'album'
        output[:id] = result['collectionId']
        output[:url] = result['collectionViewUrl'].to_am + aff
        output[:title] = result['collectionName'] + " by " + result['artistName']
      when 'artist'
        output[:type] = 'artist'
        output[:id] = result['artistId']
        output[:url] = result['artistLinkUrl'].to_am + aff
        output[:title] = result['artistName']
      end
      return false if output.empty?
      output
    else
      return false
    end
  end

  def itunes(entity, terms, dev, aff='')
    aff = @cfg['itunes_affiliate']

    url = URI.parse("http://itunes.apple.com/search?term=#{ERB::Util.url_encode(terms)}&amp;country=#{@cfg['country_code']}&amp;entity=#{entity}")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8').encode # if RUBY_VERSION.to_f &gt; 1.9

    begin
      json = JSON.parse(res)
    rescue =&gt; e
      add_error('Invalid response', "Search for #{terms}: (#{e})")
      return false
    end
    return false unless json
    if json['resultCount'] &amp;&amp; json['resultCount'] &gt; 0
      result = json['results'][0]
      case entity
      when /movie/
        # dev parameter probably not necessary in this case
        output_url = result['trackViewUrl']
        output_title = result['trackName']
      when /(mac|iPad)Software/
        output_url = dev &amp;&amp; result['sellerUrl'] ? result['sellerUrl'] : result['trackViewUrl']
        output_title = result['trackName']
      when /(musicArtist|song|album)/
        case result['wrapperType']
        when 'track'
          output_url = result['trackViewUrl']
          output_title = result['trackName'] + " by " + result['artistName']
        when 'collection'
          output_url = result['collectionViewUrl']
          output_title = result['collectionName'] + " by " + result['artistName']
        when 'artist'
          output_url = result['artistLinkUrl']
          output_title = result['artistName']
        end
      when /podcast/
        output_url = result['collectionViewUrl']
        output_title = result['collectionName']
      end
      return false unless output_url and output_title
      if dev
        return [output_url, output_title]
      else
        return [output_url + aff, output_title]
      end
    else
      return false
    end
  end

  def lastfm(entity, terms)
    url = URI.parse("http://ws.audioscrobbler.com/2.0/?method=#{entity}.search&amp;#{entity}=#{ERB::Util.url_encode(terms)}&amp;api_key=2f3407ec29601f97ca8a18ff580477de&amp;format=json")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9
    json = JSON.parse(res)
    if json['results']
      begin
        case entity
        when 'track'
          result = json['results']['trackmatches']['track'][0]
          url = result['url']
          title = result['name'] + " by " + result['artist']
        when 'artist'
          result = json['results']['artistmatches']['artist'][0]
          url = result['url']
          title = result['name']
        end
        return [url, title]
      rescue
        return false
      end
    else
      return false
    end
  end

  def define(terms)
    begin
      def_url = "https://www.wordnik.com/words/#{ERB::Util.url_encode(terms)}"
      body = %x{/usr/bin/curl -sSL '#{def_url}'}
      if body =~ /id="define"/
        first_definition = body.match(/(?mi)(?:id="define"[\s\S]*?&lt;li&gt;)([\s\S]*?)&lt;\/li&gt;/)[1]
        parts = first_definition.match(/&lt;abbr title="partOfSpeech"&gt;(.*?)&lt;\/abbr&gt; (.*?)$/)
        return [def_url, "(#{parts[1]}) #{parts[2]}"]
      end
      return false
    rescue
      return false
    end
  end

  def pinboard_bookmarks
    bookmarks = %x{/usr/bin/curl -sSL "https://api.pinboard.in/v1/posts/all?auth_token=#{@cfg['pinboard_api_key']}&amp;format=json"}
    bookmarks = bookmarks.force_encoding('utf-8')
    bookmarks.gsub!(/[^[:ascii:]]/) do |non_ascii|
      non_ascii.force_encoding('utf-8')
               .encode('utf-16be')
               .unpack('H*').first
               .gsub(/(....)/,'\u\1')
    end

    bookmarks.gsub!(/[\u{1F600}-\u{1F6FF}]/,'')

    bookmarks = JSON.parse(bookmarks)
    updated = Time.now
    result = {'update_time' =&gt; updated, 'bookmarks' =&gt; bookmarks}
    result
  end

  def save_pinboard_cache(cache)
    cachefile = PINBOARD_CACHE

    # file = File.new(cachefile,'w')
    # file = Zlib::GzipWriter.new(File.new(cachefile,'w'))
    begin
      marshal_dump = Marshal.dump(cache)
      File.write(cachefile, marshal_dump)
    rescue IOError =&gt; e
      add_error("Pinboard cache error","Failed to write stash to disk")
      return false
    end
    return true
  end

  def get_pinboard_cache
    refresh_cache = false
    cachefile = PINBOARD_CACHE

    if File.exists?(cachefile)
      begin
        file = IO.read(cachefile) # Zlib::GzipReader.open(cachefile)
        cache = Marshal.load file
        # file.close
      rescue IOError =&gt; e # Zlib::GzipFile::Error
        add_error("Error loading pinboard cache","Error reading #{cachefile}")
        return false
      end
      updated = JSON.parse(%x{/usr/bin/curl -sSL 'https://api.pinboard.in/v1/posts/update?auth_token=#{@cfg['pinboard_api_key']}&amp;format=json'})
      last_bookmark = Time.parse(updated['update_time'])
      if cache &amp;&amp; cache.key?('update_time')
        last_update = Time.parse(cache['update_time'])
        if last_update &lt; last_bookmark
          refresh_cache = true
        end
      else
        refresh_cache = true
      end
    else
      refresh_cache = true
    end

    if refresh_cache
      cache = pinboard_bookmarks
      save_pinboard_cache(cache)
    end

    return cache
  end

  def pinboard(terms)
    unless @cfg['pinboard_api_key']
      add_error('Missing Pinboard API token', "Find your api key at https://pinboard.in/settings/password and add it to your configuration (pinboard_api_key: YOURKEY)")
      return false
    end

    result = false

    regex = terms.split(/ /).map { |arg| Regexp.escape arg }.join(".*?")
    regex = /#{regex}/i

    # cache = get_pinboard_cache
    cache = pinboard_bookmarks
    bookmarks = cache['bookmarks']

    bookmarks.each {|bm|
      text = [bm['description'],bm['tags']].join(" ")
      if text =~ regex
        result = [bm['href'],bm['description']]
        break
      end
    }
    return result

  end

  def google(terms, define = false)
    begin
      uri = URI.parse("http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;filter=1&amp;rsz=small&amp;q=#{ERB::Util.url_encode(terms)}")
      req = Net::HTTP::Get.new(uri.request_uri)
      req['Referer'] = "http://brettterpstra.com"
      res = Net::HTTP.start(uri.host, uri.port) {|http|
        http.request(req)
      }
      if RUBY_VERSION.to_f &gt; 1.9
        body = res.body.force_encoding('utf-8')
      else
        body = res.body
      end

      json = JSON.parse(body)
      if json['responseData']
        result = json['responseData']['results'][0]
        return false if result.nil?
        output_url = result['unescapedUrl']
        if define &amp;&amp; output_url =~ /dictionary/
          output_title = result['content'].gsub(/&lt;\/?.*?&gt;/,'')
        else
          output_title = result['titleNoFormatting']
        end
        return [output_url, output_title]
      else
        return ddg(terms, false)
      end
    rescue
      return ddg(terms, false)
    end
  end

  def ddg(terms,type=false)

    prefix = type ? "#{type.sub(/^!?/,'!')} " : "%5C"

    begin
      body = `/usr/bin/curl -LisS 'https://lite.duckduckgo.com/lite/?q=#{prefix}#{ERB::Util.url_encode(terms)}'`
      locs = body.scan(/^location: (.*?)$/)
      return false unless locs
      url = locs[-1]
      result = url[0].strip rescue false
      return false unless result
      output_url = CGI.unescape(result)
      if @cfg['include_titles'] || @titleize
        output_title = titleize(output_url) rescue ''
      else
        output_title = ''
      end
      [output_url, output_title]
    end
  end

  def titleize(url)

    whitespace = url.match(/(\s*$)/)[0] || ''
    title = nil
    begin
      # source = %x{/usr/bin/curl -sSL '#{url.strip}'}

      uri = URI.parse(url)
      res = Net::HTTP.get_response(uri)

      if res.code.to_i == 200
        source = res.body
        unless source
          title = nil
        else
          title = source.match(/&lt;title&gt;(.*)&lt;\/title&gt;/im)
        end

        title = title.nil? ? nil : title[1].strip
      end

      if title.nil? || title =~ /^\s*$/
        $stderr.puts "Warning: missing title for #{url.strip}"
        title = url.gsub(/(^https?:\/\/|\/.*$)/,'').gsub(/-/,' ').strip
      else
        title = title.gsub(/\n/, ' ').gsub(/\s+/,' ').strip # .sub(/[^a-z]*$/i,'')
      end

      # Skipping SEO removal until it's more reliable
      # title.remove_seo(url.strip)
      title
    rescue Exception =&gt; e
      $stderr.puts "Error retrieving title for #{url.strip}"
      raise e
    end
  end

  def spell(phrase)
    unless File.exists?("/usr/local/bin/aspell")
      add_error('Missing aspell', "Install aspell in /usr/local/bin/aspell to allow spelling corrections")
      return false
    end
    words = phrase.split(/\b/)
    output = ""
    words.each do |w|
      if w =~ /[A-Za-z]+/
        spell_res =  `echo "#{w}" | /usr/local/bin/aspell --sug-mode=bad-spellers -C pipe | head -n 2 | tail -n 1`
        if spell_res.strip == "\*"
          output += w
        else
          spell_res.sub!(/.*?: /,'')
          results = spell_res.split(/, /).delete_if { |w| phrase =~ /^[a-z]/ &amp;&amp; w =~ /[A-Z]/ }
          output += results[0]
        end
      else
        output += w
      end
    end
    output
  end

  def amazon_affiliatize(url, amazon_partner)
    return url if amazon_partner.nil? || amazon_partner.length == 0

    if url =~ /https?:\/\/(?:.*?)amazon.com\/(?:(.*?)\/)?([dg])p\/([^\?]+)/
      title = $1
      type = $2
      id = $3
      az_url = "http://www.amazon.com/#{type}p/product/#{id}/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=#{amazon_partner}"
      return [az_url, title]
    else
      return [url,'']
    end
  end

  def template_social(user, url, service)
    template = @cfg['social_template']
    template.sub!(/%user%/, user)
    template.sub!(/%service%/, service)
    template.sub!(/%url%/, url.sub(/^https?:\/\/(www\.)?/,'').sub(/\/$/,''))
    template
  end

  def social_handle(type, term)
    handle = term.sub(/^@/,'').strip
    case type
    when /^t/
      url = "https://twitter.com/#{handle}"
      title = template_social(handle, url, 'Twitter')
    when /^f/
      url = "https://www.facebook.com/#{handle}"
      title = template_social(handle, url, 'Facebook')
    when /^l/
      url = "https://www.linkedin.com/in/#{handle}/"
      title = template_social(handle, url, 'LinkedIn')
    when /^i/
      url = "https://www.instagram.com/#{handle}/"
      title = template_social(handle, url, 'Instagram')
    else
      [false, term, link_text]
    end
    [url, title]
  end

  def do_search(search_type, search_terms, link_text='')
    notify("Searching", search_terms)
    return [false, search_terms, link_text] unless search_terms.length &gt; 0

    case search_type
    when /^r$/ # simple replacement
      if @cfg['validate_links']
        unless valid_link?(search_terms)
          return [false, "Link not valid: #{search_terms}", link_text]
        end
      end
      link_text = search_terms if link_text == ''
      return [search_terms, link_text, link_text]
    when /^@t/ # twitter-ify username
      if search_terms.strip =~ /^@?[0-9a-z_$]+$/i
        url, title = social_handle('t', search_terms)
        link_text = title
      else
        return [false, "#{search_terms} is not a valid Twitter handle", link_text]
      end
    when /^@fb?/ # fb-nify username
      if search_terms.strip =~ /^@?[0-9a-z_]+$/i
        url, title = social_handle('f', search_terms)
        link_text = title
      else
        return [false, "#{search_terms} is not a valid Facebook username", link_text]
      end
    when /^@i/ # fb-nify username
      if search_terms.strip =~ /^@?[0-9a-z_]+$/i
        url, title = social_handle('i', search_terms)
        link_text = title
      else
        return [false, "#{search_terms} is not a valid Instagram username", link_text]
      end
    when /^@l/ # fb-nify username
      if search_terms.strip =~ /^@?[0-9a-z_]+$/i
        url, title = social_handle('l', search_terms)
        link_text = title
      else
        return [false, "#{search_terms} is not a valid LinkedIn username", link_text]
      end
    when /^sp(ell)?$/ # replace with spelling suggestion
      res = spell(search_terms)
      if res
        return [res, res, ""]
      else
        url = false
      end
    when /^h(([sc])([hb])?)*$/
      str = $1
      types = []
      if str =~ /s([hb]*)/
        if $1.length &gt; 1
          types.push('safari_all')
        elsif $1 == 'h'
          types.push('safari_history')
        elsif $1 == 'b'
          types.push('safari_bookmarks')
        end
      end

      if str =~ /c([hb]*)/
        if $1.length &gt; 1
          types.push('chrome_bookmarks')
          types.push('chrome_history')
        elsif $1 == 'h'
          types.push('chrome_history')
        elsif $1 == 'b'
          types.push('chrome_bookmarks')
        end
      end
      url, title = search_history(search_terms, types)
    when /^a$/
      az_url, title = ddg(%Q{site:amazon.com #{search_terms}})
      url, title = amazon_affiliatize(az_url, @cfg['amazon_partner'])

    when /^g$/ # google lucky search
      url, title = ddg(search_terms)

    when /^pb$/
      url, title = pinboard(search_terms)
    when /^wiki$/
      url, title = wiki(search_terms)

    when /^def$/ # wikipedia/dictionary search
      # title, definition, definition_link, wiki_link = zero_click(search_terms)
      # if search_type == 'def' &amp;&amp; definition_link != ''
      #   url = definition_link
      #   title = definition.gsub(/'+/,"'")
      # elsif wiki_link != ''
      #   url = wiki_link
      #   title = "Wikipedia: #{title}"
      # end
      fix = spell(search_terms)

      if fix &amp;&amp; search_terms.downcase != fix.downcase
        add_error('Spelling', "Spelling altered for '#{search_terms}' to '#{fix}'")
        search_terms = fix
        link_text = fix
      end

      url, title = define(search_terms)
    when /^imov?$/ #iTunes movie search
      dev = false
      url, title = itunes('movie',search_terms,dev,@cfg['itunes_affiliate'])
    when /^masd?$/ # Mac App Store search (mas = itunes link, masd = developer link)
      dev = search_type =~ /d$/
      url, title = itunes('macSoftware',search_terms, dev, @cfg['itunes_affiliate'])

    when /^itud?$/ # iTunes app search
      dev = search_type =~ /d$/
      url, title = itunes('iPadSoftware',search_terms, dev, @cfg['itunes_affiliate'])

    when /^s$/ # software search (google)
      url, title = ddg(%Q{-site:postmates.com -site:download.cnet.com -site:softpedia.com -site:softonic.com -site:macupdate.com (software OR app OR mac) #{search_terms}})
      unless @titleize
        link_text = title if link_text == ''
      end

    when /^am/ # apple music search
      stype = search_type.downcase.sub(/^am/,'')
      otype = 'link'
      if stype =~ /e$/
        otype = 'embed'
        stype.sub!(/e$/,'')
      end
      case stype
      when /^pod$/
        result = applemusic(search_terms, 'podcast')
      when /^art$/
        result = applemusic(search_terms, 'music', 'musicArtist')
      when /^alb$/
        result = applemusic(search_terms, 'music', 'album')
      when /^song$/
        result = applemusic(search_terms, 'music', 'musicTrack')
      else
        result = applemusic(search_terms)
      end

      # {:type=&gt;,:id=&gt;,:url=&gt;,:title=&gt;}
      if otype == 'embed' &amp;&amp; result[:type] =~ /(album|song)/
        url = 'embed'
        if result[:type] =~ /song/
          link = %Q{https://embed.music.apple.com/#{@cfg['country_code']}/album/#{result[:album]}?i=#{result[:id]}&amp;app=music#{@cfg['itunes_affiliate']}}
          height = 150
        else
          link = %Q{https://embed.music.apple.com/#{@cfg['country_code']}/album/#{result[:id]}?app=music#{@cfg['itunes_affiliate']}}
          height = 450
        end

        title = %Q{&lt;iframe src="#{link}" allow="autoplay *; encrypted-media *;" frameborder="0" height="#{height}" style="width:100%;max-width:660px;overflow:hidden;background:transparent;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation"&gt;&lt;/iframe&gt;}
      else
        url = result[:url]
        title = result[:title]
      end

    when /^ipod$/
      url, title = itunes('podcast', search_terms, false)

    when /^isong$/ # iTunes Song Search
      url, title = itunes('song', search_terms, false)

    when /^iart$/ # iTunes Artist Search
      url, title = itunes('musicArtist', search_terms, false)

    when /^ialb$/ # iTunes Album Search
      url, title = itunes('album', search_terms, false)

    when /^lsong$/ # Last.fm Song Search
      url, title = lastfm('track', search_terms)

    when /^lart$/ # Last.fm Artist Search
      url, title = lastfm('artist', search_terms)
    else
      if search_terms
        if search_type =~ /.+?\.\w{2,4}$/
          url, title = ddg(%Q{site:#{search_type} #{search_terms}})
        else
          url, title = ddg(search_terms)
        end
      end
    end
    if link_text == ''
      if @titleize
        link_text = title
      else
        link_text = search_terms
      end
    end

    if url &amp;&amp; @cfg['validate_links'] &amp;&amp; !valid_link?(url) &amp;&amp; search_type !~ /^sp(ell)?/
      [false, "Not found: #{url}", link_text]
    elsif !url
      [false, "No results: #{url}", link_text]
    else
      [url, title, link_text]
    end
  end

end



sl = SearchLink.new({:echo =&gt; false})
overwrite = true
backup = sl.cfg['backup']

if ARGV.length &gt; 0
  files = []
  ARGV.each {|arg|
    if arg =~ /^(--?)?(h(elp)?|v(ersion)?)$/
      $stdout.puts "SearchLink v#{VERSION}"
      sl.help_cli
      $stdout.puts "See http://brettterpstra.com/projects/searchlink/ for help"
      Process.exit
    elsif arg =~ /^--?(stdout)$/
      overwrite = false
    elsif arg =~ /^--?no[\-_]backup$/
      backup = false
    else
      files.push(arg)
    end
  }
  files.each {|file|
    if File.exists?(file) &amp;&amp; %x{file -b "#{file}"|grep -c text}.to_i &gt; 0
      if RUBY_VERSION.to_f &gt; 1.9
        input = IO.read(file).force_encoding('utf-8')
      else
        input = IO.read(file)
      end
      FileUtils.cp(file,file+".bak") if backup &amp;&amp; overwrite

      sl.parse(input)

      if overwrite
        File.open(file, 'w') do |f|
          f.puts sl.output
        end
      else
        puts sl.output
      end
    else
      $stderr.puts "Error reading #{file}"
    end
  }
else
  if RUBY_VERSION.to_f &gt; 1.9
    input = STDIN.read.force_encoding('utf-8').encode
  else
    input = STDIN.read
  end

  sl.parse(input)
  if sl.clipboard
    print input
  else
    print sl.output
  end
end
</string>
					<key>CheckedForUserDefaultShell</key>
					<true/>
					<key>inputMethod</key>
					<integer>1</integer>
					<key>shell</key>
					<string>/usr/bin/ruby</string>
					<key>source</key>
					<string></string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.RunShellScript</string>
				<key>CFBundleVersion</key>
				<string>2.0.3</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunShellScriptAction</string>
				<key>InputUUID</key>
				<string>C656043F-2A48-4636-BDAE-4C8418E8EBAF</string>
				<key>Keywords</key>
				<array>
					<string>Shell</string>
					<string>Script</string>
					<string>Command</string>
					<string>Run</string>
					<string>Unix</string>
				</array>
				<key>OutputUUID</key>
				<string>89ED6E2B-93C9-432D-9162-A163E367BAC0</string>
				<key>UUID</key>
				<string>D9899AB4-AC1C-444F-A0A2-660F782655FE</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>inputMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<false/>
						<key>name</key>
						<string>CheckedForUserDefaultShell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>COMMAND_STRING</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
					<key>4</key>
					<dict>
						<key>default value</key>
						<string>/bin/sh</string>
						<key>name</key>
						<string>shell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>4</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>724.500000:305.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run Shell Script.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
	</array>
	<key>connectors</key>
	<dict/>
	<key>workflowMetaData</key>
	<dict>
		<key>applicationBundleIDsByPath</key>
		<dict/>
		<key>applicationPaths</key>
		<array/>
		<key>backgroundColor</key>
		<data>
		YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9i
		amVjdHMSAAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVRyb290gAGpCwwXGBki
		KCkwVSRudWxs1Q0ODxAREhMUFRZWJGNsYXNzW05TQ29sb3JOYW1lXE5TQ29s
		b3JTcGFjZV1OU0NhdGFsb2dOYW1lV05TQ29sb3KACIADEAaAAoAEVlN5c3Rl
		bV8QEXN5c3RlbVB1cnBsZUNvbG9y1RobDxwNHR4fIBJcTlNDb21wb25lbnRz
		VU5TUkdCXxASTlNDdXN0b21Db2xvclNwYWNlSzAuNSAwIDAuNSAxTxAcMC40
		MTgxOTE0OTI2IDAgMC40MjQzMDEwODc5ABABgAWACNMjJA0lJidUTlNJRFVO
		U0lDQxAHgAaAB08RDEgAAAxITGlubwIQAABtbnRyUkdCIFhZWiAHzgACAAkA
		BgAxAABhY3NwTVNGVAAAAABJRUMgc1JHQgAAAAAAAAAAAAAAAAAA9tYAAQAA
		AADTLUhQICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAAAAAAAAAABFjcHJ0AAABUAAAADNkZXNjAAABhAAAAGx3dHB0AAAB8AAA
		ABRia3B0AAACBAAAABRyWFlaAAACGAAAABRnWFlaAAACLAAAABRiWFlaAAAC
		QAAAABRkbW5kAAACVAAAAHBkbWRkAAACxAAAAIh2dWVkAAADTAAAAIZ2aWV3
		AAAD1AAAACRsdW1pAAAD+AAAABRtZWFzAAAEDAAAACR0ZWNoAAAEMAAAAAxy
		VFJDAAAEPAAACAxnVFJDAAAEPAAACAxiVFJDAAAEPAAACAx0ZXh0AAAAAENv
		cHlyaWdodCAoYykgMTk5OCBIZXdsZXR0LVBhY2thcmQgQ29tcGFueQAAZGVz
		YwAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAABJzUkdCIElF
		QzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAPNRAAEAAAABFsxYWVogAAAAAAAA
		AAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3
		hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z2Rlc2MAAAAAAAAAFklFQyBodHRw
		Oi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5j
		aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AABkZXNjAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91
		ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1
		bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAZGVzYwAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGlu
		IElFQzYxOTY2LTIuMQAAAAAAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENv
		bmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAAHZpZXcAAAAAABOk/gAUXy4AEM8UAAPtzAAEEwsAA1yeAAAAAVhZWiAA
		AAAAAEwJVgBQAAAAVx/nbWVhcwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAA
		Ao8AAAACc2lnIAAAAABDUlQgY3VydgAAAAAAAAQAAAAABQAKAA8AFAAZAB4A
		IwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQ
		AJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEB
		BwENARMBGQEfASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGa
		AaEBqQGxAbkBwQHJAdEB2QHhAekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQC
		XQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLgAusC9QMAAwsDFgMhAy0DOAND
		A08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQgBC0EOwRIBFUE
		YwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWm
		BbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkH
		Kwc9B08HYQd0B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjS
		COcI+wkQCSUJOglPCWQJeQmPCaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4K
		xQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5DBIMKgxDDFwMdQyODKcMwAzZ
		DPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62DtIO7g8JDyUP
		QQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJ
		EegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsU
		rRTOFPAVEhU0FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReu
		F9IX9xgbGEAYZRiKGK8Y1Rj6GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwb
		FBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0eHUcdcB2ZHcMd7B4WHkAeah6U
		Hr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGhIc4h+yInIlUi
		giKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaH
		Jrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8r
		Ais2K2krnSvRLAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+R
		L8cv/jA1MGwwpDDbMRIxSjGCMbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0
		njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDecN9c4FDhQOIw4yDkFOUI5fzm8
		Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4gPmA+oD7gPyE/
		YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUS
		RVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxL
		U0uaS+JMKkxyTLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGb
		UeZSMVJ8UsdTE1NfU6pT9lRCVI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9Y
		fVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyGXNZdJ114XcleGl5sXr1fD19h
		X7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9ZZJl52Y9ZpJm
		6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5r
		bsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52
		m3b4d1Z3s3gReG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7C
		fyN/hH/lgEeAqIEKgWuBzYIwgpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuH
		n4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zKjTGNmI3/jmaOzo82j56QBpBu
		kNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfgmEyYuJkkmZCZ
		/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2
		o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUSt
		uK4trqGvFq+LsACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfg
		uFm40blKucK6O7q1uy67p7whvJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C
		28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6ybnKOMq3yzbLtsw1zLXNNc21
		zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY11zX4Nhk2OjZ
		bNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T8
		5YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXx
		cvH/8ozzGfOn9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26
		/kv+3P9t///SKissLVokY2xhc3NuYW1lWCRjbGFzc2VzXE5TQ29sb3JTcGFj
		ZaIuL1xOU0NvbG9yU3BhY2VYTlNPYmplY3TSKisxMldOU0NvbG9yojEvAAgA
		EQAaACQAKQAyADcASQBMAFEAUwBdAGMAbgB1AIEAjgCcAKQApgCoAKoArACu
		ALUAyQDUAOEA5wD8AQgBJwEpASsBLQE0ATkBPwFBAUMBRQ2RDZYNoQ2qDbcN
		ug3HDdAN1Q3dAAAAAAAAAgEAAAAAAAAAMwAAAAAAAAAAAAAAAAAADeA=
		</data>
		<key>backgroundColorName</key>
		<string>systemPurpleColor</string>
		<key>customImageFileData</key>
		<data>
		iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAEumlUWHRYTUw6
		Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJX
		NU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4
		PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgog
		PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAy
		LzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjph
		Ym91dD0iIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9l
		eGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29t
		L3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFk
		b2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDov
		L25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRw
		Oi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9
		Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2
		ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjY0IgogICBleGlmOlBp
		eGVsWURpbWVuc2lvbj0iNjQiCiAgIGV4aWY6Q29sb3JTcGFjZT0iMSIKICAg
		dGlmZjpJbWFnZVdpZHRoPSI2NCIKICAgdGlmZjpJbWFnZUxlbmd0aD0iNjQi
		CiAgIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiCiAgIHRpZmY6WFJlc29sdXRp
		b249IjcyLjAiCiAgIHRpZmY6WVJlc29sdXRpb249IjcyLjAiCiAgIHBob3Rv
		c2hvcDpDb2xvck1vZGU9IjMiCiAgIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJz
		UkdCIElFQzYxOTY2LTIuMSIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjAtMDEt
		MDdUMDI6NDA6MjItMDY6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAt
		MDEtMDdUMDI6NDA6MjItMDY6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAg
		IDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJw
		cm9kdWNlZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWZmaW5pdHkg
		RGVzaWduZXIgKFNlcCAyMiAyMDE5KSIKICAgICAgc3RFdnQ6d2hlbj0iMjAy
		MC0wMS0wN1QwMjo0MDoyMi0wNjowMCIvPgogICAgPC9yZGY6U2VxPgogICA8
		L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpS
		REY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+GQoLqgAAAYFp
		Q0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZG/S0JRFMc/WmGUYVBDQ4OENWmY
		gtQSpEQFEmIGWS36/BWoPd4zIlqDVqEgaunXUH9BrUFzEBRFEE0NzUUtJa/z
		MlAiz+He+7nfe87h3nPBGssrBb3ZC4ViSYtOBJ1z8Xmn7RkLNvFu/AlFV8ci
		kTAN7eNOosVuPGatxnH/WnsqrStgaRUeVVStJDwpHF4tqSZvC3cruURK+FTY
		rckFhW9NPVnlF5OzVf4yWYtFQ2DtFHZm6zhZx0pOKwjLy3EV8ivK733Ml9jT
		xdkZWftk9KITZYIgTqYYJ0SAIUZkDuDBx6DsaJDv/cmfZllyFZlV1tBYIkuO
		Em5RV6R6WtaM6GnxPGtm///2Vc/4fdXq9iC0PBnGWz/YtqBSNozPQ8OoHEHT
		I1wUa/nLBzD8Lnq5prn2wbEBZ5c1LbkD55vQ86AmtMSP1CTDmsnA6wl0xKHr
		GtoWqj37Pef4HmLr8lVXsLsHAxLvWPwGMBxnzYSHYMEAAAAJcEhZcwAACxMA
		AAsTAQCanBgAAAbFSURBVHic7ZtZjBZFEMd/DLsseIMsK6xyqgjIuSuJ1wsh
		kQRBQUBROVQ8MB4kGvHiQROFiAm+qDEoagLEYxF9AB9U4oMmoqBcYiQCuiBG
		YJcrCrssfD7UjNMz2zPfdE9/ZBX+SWdnp6qrqmt6qruq54MzOL3RrkRy2wOX
		A4P9/zcD24ATBjLKgP7+9c9AizPrSggPeBQ4BBRi7ZBP84rIGA18CzQpfZv8
		e6NLYrUjnA+spfXA420tUKHp7wHvZOj/LlBeumHY43GKGx+0sZr+owz63+PK
		6GLT0QQzDHjP0ty70KD/3Qa8qXDlgFrgSkeysuAawgCZC64cMNORHBPc5UKI
		Cwd0AKY6kGOK6chymwsuHDAe6OJAjim6A2PyCnHhgJkOZNgidzDM64CLcPAU
		cmAc0DWPgLwOmIaD9zAHyoE78wjI6wCTtb9UyLUa5HHAFGBQHuWOMASYZNvZ
		1gETgKW2SkuA5cDNNh1tHDABeJ+2lZCUAx9g4QRTB7TFwQewcoKJAwbTdgcf
		IHBC5rzEZAlbCIwwtUjBDuBTYDGwGvgrRm8A6oGDwDlAZ0s97ZFs8xPL/lpU
		AsfInq8H7RjwGtDbQmcf4HWilSETvZUWOhPxrIURy4EeCfJ0tcik+mQ18J6F
		/qcNxpeKMuB3Q+VLYgPqhGxYlgE70a/bk3zacp+3o0LzgLcNbdjl254btxkq
		/owwuLYDngT2xXgma/RMjvHsA+YSOtLzZZvYMiX36IGvDZWq2+O6BJ4sDgha
		ncIzw9CWr3KMG4AaQ4UFJEMEuDqFx8QBBV8WQJWFPcPTBlhsH/BIEboONwJn
		I9PXFeb6MsdZ9LUZA2C/9BWA5iJ00xmQRWZSS10S02bA/egPMLKgFLtFW5kV
		wH1JxCQHlAGzLRW2RcwmYUlMcsAtJG9i/ouoBibqCEkOsA4cbRjaMekcUIOc
		vPzfcC2aZE7ngCxPvxnYBDTmNMoFGhFbmjPwPhy/EQ8MlcCtmo4HgQ+BdX7b
		oijsg5wN1iCnvqU+I9wCrALW+7bs9O938HXX+m0ycEGs71TgCWSbrYUu61tN
		9oBYBsyjdPuAeWRPcKqR+kNczjNpxqtZ3yH05/D9kFnyHMkFkmHAxpTBmDpg
		AzA0xt8BuAp4AEm4ko7nZgGHFVm7SXCimmg0An0VWnvEc40xw3YkKAXZuKxK
		GJCJA1YR3QR1B1bSulCyIMWWvsABhXe6ztjtCsMdCm0A8n2OzrjFKUoDYxs0
		/bI6oIEwuQI5BYo/hAJSXrupiC3TFP7txGbBfQrxI+X+UOCoQtsLzEc2SpcU
		URjgdo3BWR2gHrvH49M3SEAbBZyb0ZaPlf73BjcrkGJkAYmO3fz75ci7F3So
		w77OtgJzB6h1gOGEgfUo8Bh2ZxpVwH5fTj1+rjNeUTpfYX5eub/MQpmKEZg7
		IMjjOxANqFYnQAoWKLLGe0TX7XX+3wrCfP4P4KGcSjcjQSsrmpD1HmTAQ/zr
		pcg0zoN1yvVADwlyceJQxPMAi5AImgfHESdkxSa/D8hSF2BeTjtANlABBnrA
		QP+f/cBv/nWtwvSdA6UQ9bwJb2DLfuBXB3bsRFYXgAEe4edmGxSmYNNxAvje
		gVJicgoaunrvB40trh6EKr+/R7inVyN8cHS1BNlFuUCVct2goauJVTfleoVv
		yxuO7FBtaQYJNgXknVMPI1yXtdQ1+AoNfYBCXxmjubSlE/LleQHY7CEnKCA7
		o2EK43HcIniXC0jOEcduwtegNkZzactwwkPhXR6wRiHWOFSkogrJzkDe5SMa
		niOEwe9ioq+BS6hjXOMRXVdL9cmbKjft2FqlnQpb/h37etJ3aXnQjfBssAW4
		NIX3MsL3cy+Oj7iRND4YZ2RZHqMQ1HzABdQ84M0M/G8p/HVFeE2g5gEF4IY4
		wxckR2FbqJng34RxIA3VPq8uI8wDdRX6XMfQG5l2AdMiosuiKSYSLULMMOir
		FmcOkFDTz4iOyFjUlL5XEvP1ROt5W4GRhgq7IB85qJndQlOrgZdjMpZh/lX6
		SOAnRUYTcF2xTmOJ1tBagBcoHpA6Ik9qT8zwRdjl7h7wSkzWHl9HsZlZCbxI
		GFALyJha/VYp6bucQciS1C92v56wNL4R6ElYhh5EtMzUDDyIBLU8mAW8Spid
		ggzsR8WWeiRnCGzpGZOxHal7bDVR3An50Ej3G8C0dhL5qKlva5HW6OfLPGlo
		y0HgKX8s1ugKzAG+JDql4m0b8BLR7bRrDEPiybYUO1p8W+eQ4Zdopj+d7Yxs
		ZLoj6+ph5L2sJ6wlnCr0QqZ6D+A84E+kevUL+Qs4Z3Da4B8YvfYZh3T4jQAA
		AABJRU5ErkJggg==
		</data>
		<key>customImageFileExtension</key>
		<string>png</string>
		<key>inputTypeIdentifier</key>
		<string>com.apple.Automator.fileSystemObject</string>
		<key>outputTypeIdentifier</key>
		<string>com.apple.Automator.nothing</string>
		<key>presentationMode</key>
		<integer>15</integer>
		<key>processesInput</key>
		<false/>
		<key>serviceInputTypeIdentifier</key>
		<string>com.apple.Automator.fileSystemObject</string>
		<key>serviceOutputTypeIdentifier</key>
		<string>com.apple.Automator.nothing</string>
		<key>serviceProcessesInput</key>
		<false/>
		<key>useAutomaticInputType</key>
		<false/>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.servicesMenu</string>
	</dict>
</dict>
</plist>
